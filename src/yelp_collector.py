#!/usr/bin/env python3
"""
üç¥ COLLECTEUR DE DONN√âES YELP - VERSION D√âBUTANT
===============================================

Ce script fait exactement ce qui est demand√© :
1. Se connecte √† l'API Yelp Fusion
2. R√©cup√®re des restaurants √† Paris
3. R√©cup√®re les avis de chaque restaurant
4. Sauvegarde en CSV et JSON
5. Upload vers AWS S3

UTILISATION :
1. Copiez config/config_template.txt vers config/.env
2. Remplissez votre cl√© API Yelp et credentials AWS
3. Lancez : python src/yelp_collector.py

Auteur : Projet Data Engineering Yelp
Date : 2024
"""

# ===== IMPORTS (biblioth√®ques n√©cessaires) =====
import os
import json
import pandas as pd
import requests
import logging
import boto3
from datetime import datetime
from dotenv import load_dotenv
from tqdm import tqdm
import time

# ===== CONFIGURATION DU LOGGING (pour voir ce qui se passe) =====
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/yelp_collector.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class YelpCollector:
    """
    Classe simple pour collecter les donn√©es Yelp
    
    Cette classe fait tout le travail :
    - Se connecte √† l'API Yelp
    - R√©cup√®re les restaurants
    - R√©cup√®re les avis
    - Sauvegarde les donn√©es
    - Upload vers S3
    """
    
    def __init__(self):
        """Initialise le collecteur avec la configuration"""
        logger.info("üöÄ Initialisation du collecteur Yelp...")
        
        # Charger la configuration depuis le fichier .env
        self.load_config()
        
        # V√©rifier que tout est configur√©
        self.validate_config()
        
        # Pr√©parer les dossiers de sauvegarde
        self.setup_directories()
        
        logger.info("‚úÖ Collecteur initialis√© avec succ√®s !")
    
    def load_config(self):
        """Charge la configuration depuis le fichier .env"""
        logger.info("üìã Chargement de la configuration...")
        
        # Charger le fichier .env s'il existe
        env_file = "config/.env"
        if os.path.exists(env_file):
            load_dotenv(env_file)
            logger.info(f"‚úÖ Configuration charg√©e depuis {env_file}")
        else:
            logger.warning("‚ö†Ô∏è Fichier .env non trouv√©, utilisation des variables d'environnement")
        
        # R√©cup√©rer les variables de configuration
        self.yelp_api_key = os.getenv("YELP_API_KEY", "")
        self.aws_access_key = os.getenv("AWS_ACCESS_KEY_ID", "")
        self.aws_secret_key = os.getenv("AWS_SECRET_ACCESS_KEY", "")
        self.aws_region = os.getenv("AWS_REGION", "us-east-1")
        self.s3_bucket = os.getenv("S3_BUCKET_NAME", "")
        self.target_city = os.getenv("TARGET_CITY", "Paris")
        self.target_country = os.getenv("TARGET_COUNTRY", "France")
        self.max_restaurants = int(os.getenv("MAX_RESTAURANTS", "20"))
        
        # Configuration de l'API Yelp
        self.yelp_base_url = "https://api.yelp.com/v3"
        self.yelp_headers = {
            "Authorization": f"Bearer {self.yelp_api_key}",
            "Content-Type": "application/json"
        }
    
    def validate_config(self):
        """V√©rifie que la configuration est compl√®te"""
        logger.info("üîç Validation de la configuration...")
        
        # V√©rifier la cl√© API Yelp (obligatoire)
        if not self.yelp_api_key:
            logger.error("‚ùå ERREUR : Cl√© API Yelp manquante !")
            logger.error("üí° Ajoutez YELP_API_KEY dans config/.env")
            raise ValueError("Cl√© API Yelp requise")
        
        # AWS est optionnel pour commencer
        if not self.s3_bucket:
            logger.warning("‚ö†Ô∏è Bucket S3 non configur√© - pas d'upload AWS")
        
        logger.info("‚úÖ Configuration valid√©e")
    
    def setup_directories(self):
        """Cr√©e les dossiers n√©cessaires pour sauvegarder les donn√©es"""
        directories = ["data", "logs"]
        
        for directory in directories:
            if not os.path.exists(directory):
                os.makedirs(directory)
                logger.info(f"üìÅ Dossier cr√©√© : {directory}")
    
    def search_restaurants(self):
        """
        √âTAPE 1 : Recherche des restaurants √† Paris
        
        Returns:
            list: Liste des restaurants trouv√©s
        """
        logger.info(f"üîç √âTAPE 1 : Recherche de {self.max_restaurants} restaurants √† {self.target_city}...")
        
        # URL et param√®tres pour l'API Yelp
        url = f"{self.yelp_base_url}/businesses/search"
        params = {
            "location": f"{self.target_city}, {self.target_country}",
            "term": "restaurants",
            "limit": min(self.max_restaurants, 50),  # Yelp limite √† 50 par requ√™te
            "sort_by": "rating"  # Trier par note pour avoir les meilleurs
        }
        
        try:
            # Faire la requ√™te √† l'API Yelp
            logger.info("üì° Requ√™te √† l'API Yelp en cours...")
            response = requests.get(url, headers=self.yelp_headers, params=params)
            
            # V√©rifier si la requ√™te a r√©ussi
            if response.status_code == 200:
                data = response.json()
                restaurants = data.get("businesses", [])
                logger.info(f"‚úÖ {len(restaurants)} restaurants trouv√©s !")
                
                # Afficher quelques exemples pour v√©rifier
                for i, restaurant in enumerate(restaurants[:3]):
                    logger.info(f"   {i+1}. {restaurant['name']} - {restaurant['rating']}‚≠ê ({restaurant['review_count']} avis)")
                
                return restaurants
            
            else:
                logger.error(f"‚ùå Erreur API Yelp : {response.status_code}")
                logger.error(f"   Message : {response.text}")
                return []
        
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de la recherche : {str(e)}")
            return []
    
    def get_restaurant_reviews(self, restaurant_id, restaurant_name):
        """
        R√©cup√®re les avis d'un restaurant sp√©cifique
        
        Args:
            restaurant_id (str): ID Yelp du restaurant
            restaurant_name (str): Nom du restaurant (pour les logs)
            
        Returns:
            list: Liste des avis du restaurant
        """
        logger.info(f"üí¨ R√©cup√©ration des avis pour : {restaurant_name}")
        
        # URL pour les avis du restaurant
        url = f"{self.yelp_base_url}/businesses/{restaurant_id}/reviews"
        params = {"locale": "fr_FR"}  # Avis en fran√ßais si disponible
        
        try:
            # Faire la requ√™te
            response = requests.get(url, headers=self.yelp_headers, params=params)
            
            if response.status_code == 200:
                data = response.json()
                reviews = data.get("reviews", [])
                
                # Ajouter l'ID du restaurant √† chaque avis
                for review in reviews:
                    review["business_id"] = restaurant_id
                    review["business_name"] = restaurant_name
                
                logger.info(f"   ‚úÖ {len(reviews)} avis r√©cup√©r√©s")
                return reviews
            
            else:
                logger.warning(f"   ‚ö†Ô∏è Erreur {response.status_code} pour {restaurant_name}")
                return []
        
        except Exception as e:
            logger.error(f"   ‚ùå Erreur : {str(e)}")
            return []
    
    def collect_all_reviews(self, restaurants):
        """
        √âTAPE 2 : Collecte tous les avis pour tous les restaurants
        
        Args:
            restaurants (list): Liste des restaurants
            
        Returns:
            list: Liste de tous les avis collect√©s
        """
        logger.info("üí¨ √âTAPE 2 : Collecte des avis pour tous les restaurants...")
        
        all_reviews = []
        
        # Utiliser tqdm pour afficher une barre de progression
        for restaurant in tqdm(restaurants, desc="Collecte des avis"):
            restaurant_id = restaurant["id"]
            restaurant_name = restaurant["name"]
            
            # R√©cup√©rer les avis de ce restaurant
            reviews = self.get_restaurant_reviews(restaurant_id, restaurant_name)
            all_reviews.extend(reviews)
            
            # Petite pause pour ne pas surcharger l'API Yelp
            time.sleep(0.1)
        
        logger.info(f"‚úÖ Total : {len(all_reviews)} avis collect√©s pour {len(restaurants)} restaurants")
        return all_reviews
    
    def prepare_data_for_export(self, restaurants, reviews):
        """
        √âTAPE 3 : Pr√©pare les donn√©es pour l'export (nettoyage et structuration)
        
        Args:
            restaurants (list): Liste des restaurants
            reviews (list): Liste des avis
            
        Returns:
            tuple: (restaurants_df, reviews_df) DataFrames pandas
        """
        logger.info("üßπ √âTAPE 3 : Pr√©paration des donn√©es pour l'export...")
        
        # === PR√âPARATION DES DONN√âES RESTAURANTS ===
        restaurants_clean = []
        
        for restaurant in restaurants:
            # Extraire les informations importantes de fa√ßon s√©curis√©e
            clean_restaurant = {
                "id": restaurant.get("id", ""),
                "name": restaurant.get("name", ""),
                "rating": restaurant.get("rating", 0),
                "review_count": restaurant.get("review_count", 0),
                "price": restaurant.get("price", ""),
                "phone": restaurant.get("phone", ""),
                "is_closed": restaurant.get("is_closed", False),
                
                # Cat√©gories (joindre en texte)
                "categories": ", ".join([cat.get("title", "") for cat in restaurant.get("categories", [])]),
                "primary_category": restaurant.get("categories", [{}])[0].get("title", "") if restaurant.get("categories") else "",
                
                # Localisation
                "address": ", ".join(restaurant.get("location", {}).get("display_address", [])),
                "city": restaurant.get("location", {}).get("city", ""),
                "state": restaurant.get("location", {}).get("state", ""),
                "zip_code": restaurant.get("location", {}).get("zip_code", ""),
                "country": restaurant.get("location", {}).get("country", ""),
                
                # Coordonn√©es
                "latitude": restaurant.get("coordinates", {}).get("latitude", ""),
                "longitude": restaurant.get("coordinates", {}).get("longitude", ""),
                
                # M√©tadonn√©es
                "collected_at": datetime.now().isoformat()
            }
            restaurants_clean.append(clean_restaurant)
        
        # === PR√âPARATION DES DONN√âES AVIS ===
        reviews_clean = []
        
        for review in reviews:
            clean_review = {
                "review_id": review.get("id", ""),
                "business_id": review.get("business_id", ""),
                "business_name": review.get("business_name", ""),
                
                # Contenu de l'avis
                "text": review.get("text", ""),
                "rating": review.get("rating", 0),
                "time_created": review.get("time_created", ""),
                "url": review.get("url", ""),
                
                # Informations utilisateur
                "user_id": review.get("user", {}).get("id", ""),
                "user_name": review.get("user", {}).get("name", ""),
                "user_review_count": review.get("user", {}).get("review_count", 0),
                
                # M√©tadonn√©es
                "collected_at": datetime.now().isoformat()
            }
            reviews_clean.append(clean_review)
        
        # Convertir en DataFrames pandas pour faciliter l'export
        restaurants_df = pd.DataFrame(restaurants_clean)
        reviews_df = pd.DataFrame(reviews_clean)
        
        logger.info(f"‚úÖ Donn√©es pr√©par√©es : {len(restaurants_df)} restaurants, {len(reviews_df)} avis")
        
        return restaurants_df, reviews_df
    
    def save_data_locally(self, restaurants_df, reviews_df, all_data):
        """
        √âTAPE 4 : Sauvegarde les donn√©es en local (CSV et JSON)
        
        Args:
            restaurants_df: DataFrame des restaurants
            reviews_df: DataFrame des avis
            all_data: Donn√©es compl√®tes en format dictionnaire
        """
        logger.info("üíæ √âTAPE 4 : Sauvegarde des donn√©es en local...")
        
        # Cr√©er un timestamp pour les noms de fichiers
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        try:
            # === SAUVEGARDE CSV ===
            restaurants_csv = f"data/restaurants_{timestamp}.csv"
            reviews_csv = f"data/reviews_{timestamp}.csv"
            
            restaurants_df.to_csv(restaurants_csv, index=False, encoding='utf-8')
            reviews_df.to_csv(reviews_csv, index=False, encoding='utf-8')
            
            logger.info(f"‚úÖ CSV sauvegard√©s :")
            logger.info(f"   - Restaurants : {restaurants_csv}")
            logger.info(f"   - Avis : {reviews_csv}")
            
            # === SAUVEGARDE JSON ===
            json_file = f"data/yelp_data_complete_{timestamp}.json"
            
            with open(json_file, 'w', encoding='utf-8') as f:
                json.dump(all_data, f, ensure_ascii=False, indent=2)
            
            logger.info(f"‚úÖ JSON sauvegard√© : {json_file}")
            
            # Retourner les noms de fichiers pour l'upload S3
            return {
                "restaurants_csv": restaurants_csv,
                "reviews_csv": reviews_csv,
                "json_file": json_file
            }
        
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de la sauvegarde : {str(e)}")
            return None
    
    def upload_to_s3(self, file_paths):
        """
        √âTAPE 5 : Upload les fichiers vers AWS S3
        
        Args:
            file_paths (dict): Chemins des fichiers √† uploader
        """
        if not self.s3_bucket:
            logger.warning("‚è© √âTAPE 5 : Upload S3 ignor√© (bucket non configur√©)")
            return
        
        logger.info("‚òÅÔ∏è √âTAPE 5 : Upload vers AWS S3...")
        
        try:
            # Cr√©er le client S3
            s3_client = boto3.client(
                's3',
                aws_access_key_id=self.aws_access_key,
                aws_secret_access_key=self.aws_secret_key,
                region_name=self.aws_region
            )
            
            # V√©rifier/cr√©er le bucket
            try:
                s3_client.head_bucket(Bucket=self.s3_bucket)
                logger.info(f"‚úÖ Bucket {self.s3_bucket} trouv√©")
            except:
                logger.info(f"üì¶ Cr√©ation du bucket {self.s3_bucket}...")
                s3_client.create_bucket(Bucket=self.s3_bucket)
            
            # Uploader chaque fichier
            for file_type, file_path in file_paths.items():
                if file_path and os.path.exists(file_path):
                    # Nom du fichier dans S3 (garder juste le nom, pas le chemin)
                    s3_key = f"yelp-data/{os.path.basename(file_path)}"
                    
                    logger.info(f"üì§ Upload de {file_path}...")
                    s3_client.upload_file(file_path, self.s3_bucket, s3_key)
                    logger.info(f"   ‚úÖ Upload√© vers s3://{self.s3_bucket}/{s3_key}")
            
            logger.info("üéâ Tous les fichiers upload√©s vers S3 !")
        
        except Exception as e:
            logger.error(f"‚ùå Erreur upload S3 : {str(e)}")
            logger.warning("üí° V√©rifiez vos credentials AWS et le nom du bucket")
    
    def run(self):
        """
        M√âTHODE PRINCIPALE : Lance tout le processus de collecte
        """
        logger.info("üöÄ D√âBUT DE LA COLLECTE DE DONN√âES YELP")
        logger.info("=" * 60)
        
        try:
            # √âTAPE 1 : Rechercher les restaurants
            restaurants = self.search_restaurants()
            
            if not restaurants:
                logger.error("‚ùå Aucun restaurant trouv√© - arr√™t du processus")
                return
            
            # √âTAPE 2 : Collecter tous les avis
            reviews = self.collect_all_reviews(restaurants)
            
            # √âTAPE 3 : Pr√©parer les donn√©es
            restaurants_df, reviews_df = self.prepare_data_for_export(restaurants, reviews)
            
            # Cr√©er le dataset complet
            complete_data = {
                "metadata": {
                    "city": self.target_city,
                    "country": self.target_country,
                    "collection_date": datetime.now().isoformat(),
                    "total_restaurants": len(restaurants),
                    "total_reviews": len(reviews)
                },
                "restaurants": restaurants,
                "reviews": reviews
            }
            
            # √âTAPE 4 : Sauvegarder localement
            file_paths = self.save_data_locally(restaurants_df, reviews_df, complete_data)
            
            # √âTAPE 5 : Upload vers S3
            if file_paths:
                self.upload_to_s3(file_paths)
            
            # RAPPORT FINAL
            logger.info("üìä RAPPORT FINAL")
            logger.info("=" * 40)
            logger.info(f"üè™ Restaurants collect√©s : {len(restaurants)}")
            logger.info(f"üí¨ Avis collect√©s : {len(reviews)}")
            logger.info(f"üìÅ Fichiers sauvegard√©s : {len(file_paths) if file_paths else 0}")
            logger.info("üéâ COLLECTE TERMIN√âE AVEC SUCC√àS !")
        
        except KeyboardInterrupt:
            logger.info("‚èπÔ∏è Collecte interrompue par l'utilisateur")
        except Exception as e:
            logger.error(f"üí• Erreur fatale : {str(e)}")


def main():
    """Point d'entr√©e principal du script"""
    print("üç¥ Collecteur de Donn√©es Yelp - Version D√©butant")
    print("=" * 50)
    
    # Cr√©er et lancer le collecteur
    collector = YelpCollector()
    collector.run()


# Lancer le script si ex√©cut√© directement
if __name__ == "__main__":
    main() 